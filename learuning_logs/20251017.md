# TypeScript로 리액트 앱 만들기 실습 예제
```tsx
import { useState } from 'react';
import './App.css'

function App() {
  const [ name, setName ] = useState(''); 
  
  const handleChange = (event : React.ChangeEvent<HTMLInputElement>) => {
    setName(event.target.value);
  }

  const handleSubmit = (event : React.FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    alert(`Hello ${name} ⭐`);
  }

  return (
    <>
      <form onSubmit={handleSubmit}>
        <input type="text" value={name} onChange={handleChange}/>
        <input type="submit" value='제출' />
      </form>
    </>
  )
}

export default App
```

# React RESTful API 구현
리액트를 이용한 네트워킹 실습을 할 예정입니다. cardatabase를 기준으로 다양한 react 적용 기술들을 jsx / tsx로 구현할 것이고, 이를 위해서 특히 네트워킹 파트에 fetch 및 axios를 실습합니다. 이는 비동기 코드를 더 깔끔하고 가독성있게 만들 수 있는 Promise 개념에 대해서 사전 학습이 되어있어야만 가능합니다.

Promise 역시도 js에 딸려있는 기능 중 하나였지만 그때는 설명하지 않았습니다.

react-query를 라이브러리를 이용하여 실제로 작동이 어떤식으로 이루어지는지에 대한 설명도 할 예정입니다.

## ts 프로젝트 생성
1. weatherapp - react - jsx 형태로 생성해주세요.
2. App.jsx를 초기화해주세요.
3. npm run dev를 통해서 빈 브라우저 화면을 출력하세요.

이상을 이용해 간단한 RESTful API 구현을 하도록 하겠습니다.

## Promise
- 비동기 연산을 처리하는 방법으로, 전통적인 방법은 연산의 성공 또는 실패에 callback function을 작성해두는 것입니다. 예를 들어 GET 요청을 했다고 가정했을 때, 이에 성공했다면 success() 함수를 호출하고, 실패했을 때는 failure() 함수를 호출하는 것처럼요. 이하는 이를 추상적으로 작성한 예시입니다.
```js
function doAsyncCall(success, failure) {
  // 어떤 API 호출

  if(SUCCEED) {
    success(resp);
  } else {
    failure(err);
  }
}

function success(response) {
  // 응답을 가지고 작업 수행
}

function failure(error) {
  // 오류를 처리하는 로직
}
```
이상은 예전에 이런 구조로 작성했었다는 의미입니다. 현재의 Promise는 JS에서 비동기 프로그래밍의 기본 요소기 때문에 Promise를 기반으로 한 코딩을 하게 됩니다.
그러면 Promise가 뭐냐 ? 가 문제가 됩니다.

Promise란? -> 비동기 연산의 결과를 나타내는 JS 객체.

이를 이용하면 비동기 호출을 실행할 때 코드가 좀 단순화됩니다. 얘가 없던 시절에는 코드를 읽고 유지 관리하는 게 엄청 골치아팠었습니다. 여러 개의 중첩된 callback function들이 있어야만 했거든요.

요청을 전송하는 데 이용하는 API 또는 라이브러리가 프로미스를 지원하는 경우, 프로미스를 이용한 비동기 호출을 실행할 수 있습니다(오늘날에는 대부분 지원하구요). 이하에서는 비동기 호출 수행 및 관련 예제입니다.

```js
doAscyCall().then(response => 뭐 어떤 로직);
```

즉, 아까 위에위에 js 함수 정의를 했던 부분들 중에, doAsycCall()의 내부에서 if절 부분이 다 필요 없어지는 작성 방식이라고 할 수 있습니다.

이상의 호출 부분을 해석하기 위해서는 method의 결과가 return되고, 이것이 다음 .then() 메서드를 실행하는 객체가 된다는 점을 이해하고, builder 패턴에서 처음 배웠던 chaining method 개념이 익숙하다면 충분히 해석하실 수 있을겁니다.

응답이 반환됐을 때, then() 메서드 내부에 callback 함수가 실행되어 응답을 argument로 받게 됩니다(그래서 예시에 response라는 매개변수 명을 달아놨습니다).

그렇다면 여기서 의문을 가져야 하는 점은 then() 메서드의 return 자료형이겠네요.

then() 메서드의 return 자료형 : Promise.
그리고, 이 Promise는 세 가지 상태 중 하나에 속합니다.
1. 대기(Pending) : 초기 상태
2. 이행(Resolved) : 작업 성공
3. 거부(Rejected) : 작업 실패

이하의 예시는 프로미스를 단순화시킨 형태로, 특히 setTimeout을 활용하여 비동기 연산을 시뮬레이션했습니다.
```js
const myPromise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello');
  }, 500);
});
```
1. JS에서도 생성자를 통한 객체 생성이 가능합니다. 즉, 95번 라인에서는 저희가 myPromise라는 객체를 생성했다고 볼 수 있습니다.
2. 해당 myPromise 객체는 resolve 매개변수와 reject 매개변수를 가집니다.
3. 프로미스 객체가 생성될 때와, 타이머가 실행되는 동안 프로미스는 대기 상태에 있습니다. 그리고 500 밀리초가 지나면 'Hello'라는 값으로 resolve 함수가 호출되고, 프로미스는 _이행_ 상태로 갑니다. 오류가 발생하면 _거부_ 상태로 넘어가겠네요. 현재는 _거부_ 에서 처리하는 로직을 작성하지 않았습니다.

그리고 이상에서 배웠던 .then() 메서드를 통해 인스턴스를 서로 연결하여 다수의 비동기 작업을 _순차적으로_ 진행시키는 것이 가능합니다.
```js
doAsyncCall().then(response => 전체 응답 결과가 나온 것을 가지고 비지니스 로직 수행).then
.then(data => response를 가공한 결과값을 매개변수 data로 이름 붙이고 추가적인 비지니스 로직 수행)
```
그리고 rejected된 상태에서의 오류 처리를 추가하는 것이 가능합니다.
```js
doAsyncCall().then(response => 전체 응답 결과가 나온 것을 가지고 비지니스 로직 수행).then
.then(data => response를 가공한 결과값을 매개변수 data로 이름 붙이고 추가적인 비지니스 로직 수행)
.catch(error => console.log(error));
```
그러면 저희가 Java에서 배웠던 예외처리 방법에서처럼 doAscycCall()과 두 개의 .then() 메서드들 중에서 어디에서라도 오류/예외가 발생하면 catch 부분으로 넘어가게 됩니다.

개발자는 콘솔에 찍힌 error를 보고 이를 수정하게 될겁니다.

## async / await
비동기 호출을 처리하는 좀 더 최신 방식은 ECMAScript2017에 도입된 async/await을 이용하는 방식입니다. 이는 Promise에 대한 개념을 알고 있다는 전제 하에 사용하는 것이 정신건강에 좋습니다. 얘를 쓰려면 await 표현식을 포함할 수 있는 async() 함수를 정의해야하거든요...

이하는 async / await의 비동기 호출 예시입니다.
```jsx
const doAsyncCall = async () => {
  const response = await fetch('http://someapi.com');
  const data = await response.json();
  // 그리고 data를 가지고 로직 수행하는 부분을 정의
}
```
여기서 fetch() 함수가 나오는데, 얘의 return 값도 Promise입니다. 다만, async / await을 도입했을 경우 .then()을 쓰는 것이 아니라 awqit 키워드를 써야 합니다.

그리고 오류 처리를 위해서 마찬가지로 async / await에 try-catch문을 쓸 수도 있습니다. 이하는 그 예시입니다.
```js
cpmst dpAsucCall = async () => {
  try {
    const response = await fetch('http://someapi.com');
    const data = await response.json();
    // data를 가지고 추가적인 비지니스 로직 정의
  }
  catch {
    console.log(error);
  }
}
```
이상까지가 전반적인 Promise의 정의와 사용 최근 사례입니다.
이를 이용하면 React 앱에서 request 작업에서 사용하는 fetchAPI에 대해서 학습할 준비가 된겁니다.